<html>

<head>
    <script src='./SDL.js'></script>

    <script>

        class EventEmitter {
            constructor() {
                this.events = {};
            }
            on(event, listener) {
                if (typeof this.events[event] !== 'object') {
                    this.events[event] = [];
                }
                this.events[event].push(listener);
                return () => this.removeListener(event, listener);
            }
            removeListener(event, listener) {
                if (typeof this.events[event] === 'object') {
                    const idx = this.events[event].indexOf(listener);
                    if (idx > -1) {
                        this.events[event].splice(idx, 1);
                    }
                }
            }
            emit(event, ...args) {
                if (typeof this.events[event] === 'object') {
                    this.events[event].forEach(listener => listener.apply(this, args));
                }
            }
            once(event, listener) {
                const remove = this.on(event, (...args) => {
                    remove();
                    listener.apply(this, args);
                });
            }
        };


        class TestApp1 extends EventEmitter {

            constructor() {
                super();
                let appID = (Math.floor(Date.now() / 1000) + '').substr(7);

                let appConfig = {
                    "appName": appID,
                    "appID": appID,
                    "fullAppID": appID,
                    "appHMIType": [
                        "DEFAULT",
                        "MEDIA"
                    ],
                    "hmiDisplayLanguageDesired": "EN-US",
                    "isMediaApplication": false,
                    "languageDesired": "EN-US",
                    "syncMsgVersion": {
                        "majorVersion": 3,
                        "minorVersion": 1,
                        "patchVersion": 0
                    }
                };

                this._eventListeners = [];
                this._appConfig = appConfig;
                let baseTransportConfig = new SDL.transport.WebsocketTransportConfig('ws://localhost', 9090);
                this._sdlSession = new SDL.session.WsClientSession(baseTransportConfig, this);
                this._maxCorrelationId = 0;
            }

            static async startApp() {
                let obj = new this();
                await obj._init();
                return obj;
            }

            async _init() {
                console.log('start connection');
                await this._startConnection();
                console.log('start service');
                await this._startService();
                console.log('register app');
                await this._registerApp();
                console.log('set app icon');
                await this._setAppIcon();
            }

            async _fetchImageBase64(path) {
                let img = await fetch(path);
                let blob = await img.blob();
                return blob;
                // return this.blobToBase64(blob);
            }

            async _fetchImageUnit8Array(path) {
                let img = await fetch(path);
                let blob = await img.blob();
                let aryBuffer = await new Response(blob).arrayBuffer();
                return new Uint8Array(aryBuffer);
            }

            async _setAppIcon() {
                let fileBinary = await this._fetchImageUnit8Array('./test_icon_1.png');
                let fileName = this._appConfig.appID + '_icon.gif';
                let fileType = 'GRAPHIC_PNG';

                let putFile = await this.sendRPCJson({
                    method: 'PutFile',
                    params: {
                        syncFileName: fileName,
                        fileType,
                        persistentFile: true,

                    },
                    bulkData: fileBinary //unit8 array

                });


                let setIconResult = await this.sendRPCJson({
                    method: 'SetAppIcon',
                    params: {
                        syncFileName: fileName,
                    }
                });

            }

            async _registerApp() {
                let result = await this.sendRPCJson(
                    {
                        method: 'RegisterAppInterface',
                        params: this._appConfig,
                    }
                );
            }

            async sendRPCJson(
                data
            ) {
                let { method, params, bulkData } = data;
                let id = ++this._maxCorrelationId;

                let rpcRequest = new SDL.rpc.RpcRequest(
                    {
                        functionName: method,
                        parameters: params,
                        rpcType: SDL.rpc.enums.RpcType.REQUEST,
                    }
                );
                rpcRequest.setCorrelationID(id);

                //bulk data is blob.
                if (bulkData) {
                    rpcRequest.setBulkData(bulkData);
                }


                return await this.sendRPC(rpcRequest);


            }

            async sendRPC(rpcRequest) {

                const self = this;
                return new Promise((resolve) => {
                    let correlationId = rpcRequest.getCorrelationID();

                    self.on('INCOMING_RPC', (rpcResponse) => {
                        let responseCorrelationId = rpcResponse.getCorrelationID();

                        if (responseCorrelationId === correlationId) {
                            return resolve(rpcResponse);
                        }
                    });

                    self._sdlSession.sendRpc(rpcRequest);

                })
            }

            async _startService() {

                const self = this;
                return new Promise((resolve) => {
                    self.on('onProtocolSessionStarted', () => {
                        return resolve();
                    });

                    self._sdlSession.startService(SDL.protocol.enums.ServiceType.RPC, 0, false);

                })
            }

            async _startConnection() {
                const self = this;
                return new Promise((resolve) => {
                    self.once('onTransportConnected', () => {
                        return resolve();
                    });
                    self._sdlSession.start();
                })
            }

            async onTransportConnected() {
                this.emit('onTransportConnected', {})
            }
            async onProtocolSessionEnded() {
            }
            async onProtocolSessionEndedNACKed() {
            }

            async onProtocolSessionStarted() {
                this.emit('onProtocolSessionStarted')
            }

            async onRpcMessageReceived(rpcMessage) {
                let functionName = rpcMessage.getFunctionName();
                let parameters = rpcMessage.getParameters();
                this.emit('INCOMING_RPC', rpcMessage);
            }

            async _unregister() {
                await this.sendRPCJson({
                    'method': 'UnregisterAppInterface'
                })
            }

            async exit() {
                await this._unregister();
                this._sdlSession.endSession();
            }
        }

    </script>


    <script>

        async function sleep(timeout = 1000) {
            return new Promise((resolve) => {
                setTimeout(resolve, timeout);
            })
        }



        (async function () {
            console.log('start app');
            let app = await TestApp1.startApp();

            console.log('app started and registered', app);
            console.log('start listeners');
            app.on('INCOMING_RPC', async (rpcMessage) => {
                let functionName = rpcMessage.getFunctionName();

                console.log(`INCOMING_RPC`, functionName, rpcMessage);

                if (functionName === 'OnHMIStatus') {
                    let parameters = rpcMessage.getParameters();
                    let { hmiLevel } = parameters;
                    if (hmiLevel === 'FULL') {

                        let rpcResponse = await app.sendRPCJson(
                            {
                                "method": "Show",
                                "params": {
                                    "mainField1": "こんにちは",
                                    "mainField2": "你好 ( ni hao / nĭ hăo )",
                                    "mainField3": "@#$#%$^^%&**&(_     !@#$@#$~~~```"
                                }
                            }
                        );
                        console.log(`show message response`, rpcResponse);

                        await sleep();

                        let count = 3;
                        for (let i = 0; i < count; i++) {
                            let rpcResponse = await app.sendRPCJson(
                                {
                                    "method": "Show",
                                    "params": {
                                        "mainField1": "Exiting in " + (count - i).toString(),
                                        "mainField2": "",
                                        "mainField3": "",

                                    }
                                }
                            );

                            await sleep();

                        }
                        app.exit();

                    }

                }
            });

            // app.on('INCOMING_RPC.OnHMIStatus', (rpcMessage) => {
            //     console.log(`hmi status update`, rpcMessage);
            // });

        })();
    </script>
</head>


<body>

    <!-- <img src="./test_icon_1.png" /> -->

</body>

</html>